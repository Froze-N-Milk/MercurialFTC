package org.mercurialftc.mercurialftc.silversurfer.follower;

import com.qualcomm.robotcore.hardware.DcMotorEx;
import org.jetbrains.annotations.NotNull;
import org.mercurialftc.mercurialftc.silversurfer.followable.Followable;
import org.mercurialftc.mercurialftc.silversurfer.followable.motionconstants.MecanumMotionConstants;
import org.mercurialftc.mercurialftc.silversurfer.geometry.angle.AngleRadians;
import org.mercurialftc.mercurialftc.silversurfer.geometry.Vector2D;
import org.mercurialftc.mercurialftc.silversurfer.tracker.Tracker;
import org.mercurialftc.mercurialftc.util.matrix.SimpleMatrix;

public class MecanumArbFollower extends ArbFollower {
	private final DcMotorEx fl, bl, br, fr;
	private final SimpleMatrix transformMatrix;
	private final Tracker tracker;

	/**
	 * an arbitrary feed forward output follower
	 *
	 * @param motionConstants motion constants to be used for scaling to power outputs
	 * @param fl              front left motor
	 * @param bl              back left motor
	 * @param br              back right motor
	 * @param fr              front right motor
	 */
	public MecanumArbFollower(@NotNull MecanumMotionConstants motionConstants, @NotNull Tracker tracker, @NotNull DcMotorEx fl, @NotNull DcMotorEx bl, @NotNull DcMotorEx br, @NotNull DcMotorEx fr) {
		super(motionConstants);
		this.tracker = tracker;
		this.fl = fl;
		this.bl = bl;
		this.br = br;
		this.fr = fr;

		transformMatrix = new SimpleMatrix(
				new double[][]{
						{1, 1, -1},
						{1, -1, -1},
						{1, 1, 1},
						{1, -1, 1}
				}
		);
	}

	/**
	 * transforms the output for use in {@link #follow(Vector2D, double, double)} and then feeds it in
	 *
	 * @param output   the output velocities and information, usually generated by a wave
	 * @param loopTime current loop time, to ensure performance
	 */
	@Override
	protected void followOutput(@NotNull Followable.Output output, double loopTime) {
		MecanumMotionConstants.DirectionOfTravelLimiter directionOfTravelLimiter = getMotionConstants().makeDirectionOfTravelLimiter(output.getTranslationVector().getHeading());

		Vector2D translationVector = output.getTranslationVector().scalarMultiply(1 / directionOfTravelLimiter.getVelocity());
		double rotationalVelocity = output.getRotationalVelocity() / getMotionConstants().getMaxRotationalVelocity();

		follow(translationVector, rotationalVelocity, loopTime);
	}

	/**
	 * takes in a unit translation vector and a unit rotational velocity, rotates the translation to make it field centric, arranges the inputs into per-wheel outputs
	 *
	 * @param translationVector  should be a unit vector
	 * @param rotationalVelocity should be in the domain [-1, 1]
	 */
	@Override
	public void follow(@NotNull Vector2D translationVector, double rotationalVelocity, double loopTime) {
		translationVector = translationVector.rotate(new AngleRadians(0).subtract(tracker.getPose2D().getTheta()));

		SimpleMatrix inputValues = new SimpleMatrix(
				new double[][]{
						{translationVector.getY()},
						{translationVector.getX()},
						{rotationalVelocity}
				}
		);

		SimpleMatrix outputMatrix = transformMatrix.multiply(inputValues);

		double maxPower = 1;

		for (int i = 0; i < outputMatrix.rows(); i++) {
			maxPower = Math.max(maxPower, Math.abs(outputMatrix.getItem(i, 0)));
		}

		outputMatrix = outputMatrix.scalarMultiply(1 / maxPower);

		fl.setPower(outputMatrix.getItem(0, 0));
		bl.setPower(outputMatrix.getItem(1, 0));
		br.setPower(outputMatrix.getItem(2, 0));
		fr.setPower(outputMatrix.getItem(3, 0));
	}
}
